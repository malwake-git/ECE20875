So now we're going to discuss WiFi's distributed coordination function, DCF as we said before, which is a particular implementation of the Carrier sensing multiple access or CSMA random access protocol.

The basic operation of CSMA is quite simple and very intuitive. It relies on the idea of carrier sensing. So suppose you are a transmitter. Before you send any packet, you will regularly listen to the air, which is the part of the frequency spectrum where your communication channel lies you don't have to listen to frequencies that are not in the same channel as your frequency width because they will not be interfering with you anyway, to see if any others are transmitting. So you want to listen to the air to see if any other transmissions are occurring. This is called carrier sensing. And as this diagram illustrates each transmitter needs to observe what is known as a wait and listen period before they can attempt transmission.

If the channel is sensed as busy during this wait and listen time, so if someone is using the medium to transmit her packets, then you just stay silent. But if it's idle and nobody is using it, then you can go ahead and send a sequence of packets. You may want to send a lot of them in a row, so you can send a control message also to declare how long you want to use the channel, your station could say hey I want to hold the channel for a given amount of time, but the channel holding time is going to have an upper bound obviously just like treadmill sharing in a gym you can't hold a treadmill for a long period of time because other people may want to use it.

So CSMA when a packet is received the receiver is going to send an acknowledgment packet back to the source, and that notifies the sender that everything went OK. The receiver also has to go through a wait and listen period, and that period is called the SIFS instead of the DIFS, the DIFS is the wait and listen period for the transmitter and the SIFS is the one the receiver has to go through, and SIFS is naturally shorter because those are higher priority messages and they have to get back quicker to the source so the source knows that everything went OK and it doesn't then decide that it wants to retransmit.

So this is an example to three stations A B and C here B is the receiver and A and C are both transmitting stations. A sends a packet of data to B and then B after waiting the SIFS period sends its ACK back to A. Then C station C before it can send to B it has to go through another wait and listen period, this DIFS period, which is longer than the SIFS period that B had to wait before sending its ACK back to A, and then it can send data to B. And then it turns out in the end that C suffers a collision which we'll talk about in a second.

So if your frame collides with some other frames when you try to send it, your receiver is not going to get it, and you will not get an acknowledgment either. So in this case C is going to suffer a collision and then C is not going to get an acknowledgment back from B. This is how you know that you suffered a collision and you need to back off. So you can tell that a collision occurred by the lack of these acknowledgment packets. This is how you tell collisions. And technically it doesn't have to be just a collision, it could have been something else that made it so that your packet did not get to the receiver successfully and therefore you will want to retransmit. But the key idea here is that instead of retransmitting immediately you're going to need to back off then, because when collisions happen that means that the congestion conditions may not be so good in the network. So what you do is you double what's called the contention window size. And then you're going to draw a random number between 0 and the current window size. So if your contention window prior was, say it was 4 roughly then you're going to double that and it will be 8. And then you're going to choose a random number between 0 and 8. And technically rather than going from 4 to 8 it would go from 3 to 7, it's technically 2 to the N - 1, but the idea is the same. Then you're going to draw a random number, and that's the number of periods you're going to have to wait before you're going to have your next chance of retransmitting. So a higher window size means you're going to have to wait longer and see a longer period of the channel being idle.

So this protocol description might sound pretty unmotivated at first, the idea of having acknowledgments, having backoffs, and then retransmitting based on the backoffs, but there's actually two clever ideas of distributed coordination and distributed control coordination control distributed coordination or distributed control that are in here. And those are randomization and exponential backoff. The idea of randomization is that if two stations A and B have their frames collide at one time, you dont want them to be backing off to a common time in the future, because that will just cause another collision, so if we have A and B and they both transmit and they both then collide, if they both wait the same period of time before retransmitting again say that time is here and they both retransmit at a same or common time, they're just going to collide again, it doesn't matter how long they waited if it's the same time it's going to cause a collision. So rather than backing off to a common time we randomize this, so we have A choose some random time maybe that ends up being here, and maybe B ends up being here, and hopefully they won't end up colliding again. And of course it might so happen that they might pick the same timeslot again, but this is the price we pay for distributed coordination rather than having a centralized controller that would make sure they would not be transmitting at the same times. That's the idea of randomization: choosing random transmissions.

The second is exponential backoff. So if frames keep colliding, you know that the interference conditions are very bad, because more collisions would tend to mean there is more congestion, so you as well as those other stations that are experiencing persistent collision of their frames should start to back off more. In this way acknowledgments serve as implicit feedback mechanism about the network conditions. So the acknowledgment packets are really a mechanism for feedback to the transmitters to know what the congestion conditions are like. But there's a particular way we deal with this lack of acknowledgments, it's by changing the window size. One option would be to change the window size linearly, if we had a linear increase it would go say 3 to 4 to 5 to 6 and so forth, and it would keep going on every time we didn't get an acknowledgment. But people felt that would not be aggressive enough, so instead we use multiplicative backoff, so this exponential backoff is multiplicative, and since the multiplicative factor happens to be 2 because we're doubling, it's called binary exponential backoff. So a binary exponential backoff instead of being linear like that would go say from 3 and next to 7 I'm doing N - 1 here, so 2 squared is 4 minus 1 is 3, 2 cubed is 8 minus 1 is 7, then it would go to 15, then it would go up to 31, and so forth.

And so these are two really clever ideas of distributed coordination that are in here: the idea of randomization, choosing random transmission times, and the idea of having exponential backoff, in particular binary exponential backoff to make backoff pretty aggressive.